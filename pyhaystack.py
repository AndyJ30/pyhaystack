#!python
# -*- coding: utf-8 -*-
"""
File : pyhaystack.py (2.x)
This module allow a connection to a haystack server
Feautures provided allow user to fetch data from the server and eventually, to post to it.

See http://www.project-haystack.org for more details

Project Haystack is an open source initiative to streamline working with data from the Internet of Things. We standardize semantic data models and web services with the goal of making it easier to unlock value from the vast quantity of data being generated by the smart devices that permeate our homes, buildings, factories, and cities. Applications include automation, control, energy, HVAC, lighting, and other environmental systems.

"""
__author__ = 'Christian Tremblay'
__version__ = '1.07'
__license__ = 'AFL'

import requests
import json
import pandas as pd
import matplotlib.pyplot as plt
import csv

class HaystackConnection():
    """
    Abstact class / Make a connection object to haystack server using requests module
    A class must be made for different type of server. See NiagaraAXConnection(HaystackConnection)
    """
    def __init__(self, url, username, password):
        """
        Set local variables
        Open a session object that will be used for connection, with keep-alive feature
        """
        self.baseURL = url
        self.queryURL = ''
        self.USERNAME = username
        self.PASSWORD = password
        self.COOKIE = ''
        self.isConnected = False
        self.s = requests.Session()
    def authenticate(self):
        """
        This function must be overridden by specific server connection to fit particular needs (urls, other conditions)
        """
        pass
    def getJson(self,urlToGet):
        """
        Helper for GET request. Retrieve information as json string objects
        """
        if self.isConnected:
            try:
                req = self.s.get(self.queryURL + urlToGet, headers={'accept': 'application/json; charset=utf-8'})
                #print 'GET : %s | url : %s' % (req.text, urlToGet)
                return json.loads(req.text)
            except requests.exceptions.RequestException as e:
                print 'Request GET error : %s' % e
        #else:
        #print 'Session not connected to server, cannot make request'
        else:
            print 'Session not connected to server, cannot make request'
        
    def getZinc(self,urlToGet):
        """
        Helper for GET request. Retrieve information as json string objects
        """
        if self.isConnected:
            try:
                req = self.s.get(self.queryURL + urlToGet, headers={'accept': 'text/plain; charset=utf-8'})
                #print 'GET : %s | url : %s' % (req.text, urlToGet)
                return (req.text)
            except requests.exceptions.RequestException as e:
                print 'Request GET error : %s' % e
        else:
            print 'Session not connected to server, cannot make request'
    
    def postRequest(self,url,headers={'token':''}):
        """
        Helper for POST request
        """
        try:
            req = self.s.post(url, params=headers,auth=(self.USERNAME, self.PASSWORD))
            #print 'POST : %s | url : %s | headers : %s | auth : %s' % (req, url, headers,self.USERNAME) Gives a 404 response but a connection ????
        except requests.exceptions.RequestException as e:    # This is the correct syntax
            print 'Request POST error : %s' % e




class NiagaraAXConnection(HaystackConnection):
    """
    This class connects to NiagaraAX and fetch haystack servlet
    A session is open and authentication will persist
    """
    def __init__(self,url,username,password):
        """
        Define Niagara AX specific local variables : url
        Calls the authenticate function
        """
        HaystackConnection.__init__(self,url,username,password)
        self.loginURL = self.baseURL + "login/"
        self.queryURL = self.baseURL + "haystack/"
        self.requestAbout = "about"
        self.authenticate()
        
    def authenticate(self):
        """
        Login to the server
        Get the cookie from the server, configure headers, make a POST request with credential informations.
        When connected, ask the haystack for "about" information and print connection information
        """
        print 'pyhaystack %s | Authentication to %s' % (__version__,self.loginURL)
        try:
            self.COOKIE = self.s.get(self.loginURL).cookies
        except requests.exceptions.RequestException as e:
            print 'Problem connecting to server : %s' % e
            
        #Version 3.8 gives a cookie
        if self.COOKIE:
            self.COOKIEPOSTFIX = self.COOKIE['niagara_session']
            self.headers = {'cookiePostfix' : self.COOKIEPOSTFIX
                           }
        self.headers =  {'token':'',
                         'scheme':'cookieDigest',
                         'absPathBase':'/',
                         'content-type':'application/x-niagara-login-support',
                         'Referer':self.baseURL+'login/',
                         'accept':'application/json; charset=utf-8'
                        }
        self.auth = self.postRequest(self.loginURL,self.headers)
        self.isConnected = True
        self.about = self.getJson(self.requestAbout)
        self.serverName = self.about['rows'][0]['serverName']
        self.haystackVersion = self.about['rows'][0]['haystackVersion']
        self.axVersion = self.about['rows'][0]['productVersion']
        print 'Connection made with haystack on %s (%s) running haystack version %s' %(self.serverName,self.axVersion,self.haystackVersion)
            
        #Maybe a version lower than 3.8 without cookie
        #else:
        #    
        #    print "Not connected, it's over now"
        #    self.isConnected = False

class Histories():
    """
    This class gathers every histories on the Jace
    """
    def __init__(self, session, format='zinc'):
        self.hisListName = []
        self.hisListId = []
        requestHistories = "read?filter=his"
        if format == 'json':
            histories = session.getJson(requestHistories)
            #prettyprint(histories)
            for each in histories['rows']:
                self.hisListName.append(each['id'].split(' ')[1])
                self.hisListId.append(each['id'].split(' ')[0])
        elif format == 'zinc':
            histories = session.getZinc(requestHistories)
            his_to_csv = histories.replace(u'\xb0C','').split('\n')[2:]
            reader = csv.reader(his_to_csv)
            for lines in reader:
                self.hisListName.append(lines[9].split(' ')[1])
                print 'Found %s, adding to list' % lines[9].split(' ')[0]
                self.hisListId.append(lines[9].split(' ')[0])
            
    def getListofId(self):
        return self.hisListId

class UnknownHistoryType(Exception):
    """
    Utility Exception class needed when dealing with non-standard histories
    Analyse_zone for example
    """
    pass

class HisRecord():
    """
    This class is a single record
    """
    def __init__(self,session,hisId,dateTimeRange):
        """
        GET data from server and fill this object with historical info
        """
        self.hisId = hisId
        self.jsonHis = session.getJson('hisRead?id='+self.hisId+'&range='+dateTimeRange)
        try:
            self.data = pd.DataFrame(self.jsonHis['rows'],columns=['ts', 'val'])
            #print '%s added to list' % self.hisId
        except Exception:
            print '%s is an Unknown history type' % self.hisId 
    
    def plot(self):
        """
        Draw a graph of the DataFrame
        """
        self.data.plot()


def parseDateTime(ts):
    """
    Method to parse DateTime format
    """
    date = ts.split('T')[0]
    time = ts.split('T')[1].split(' ')[0][:-6]
    tz = ts.split('T')[1].split(' ')[1]
    tzOffset = ts.split('T')[1].split(' ')[0][-6:]
    
    hour = time.split(':')[0]
    minute = time.split(':')[1]
    second = time.split(':')[2]

    dateTime = {'toString':date+'/'+time,
                'date':date,
                'time':time,
                'hour':hour,
                'minute':minute,
                'second':second,
                'tz':tz,
                'tzOffset':tzOffset
                }
    return dateTime
    
def prettyprint(jsonData):
    """
    Pretty print json object
    """
    print json.dumps(jsonData, sort_keys=True, indent=4)