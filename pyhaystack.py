#!python
# -*- coding: utf-8 -*-
"""
File : pyhaystack.py (2.x)
This module allow a connection to a haystack server
Feautures provided allow user to fetch data from the server and eventually, to post to it.

See http://www.project-haystack.org for more details

Project Haystack is an open source initiative to streamline working with data from the Internet of Things. We standardize semantic data models and web services with the goal of making it easier to unlock value from the vast quantity of data being generated by the smart devices that permeate our homes, buildings, factories, and cities. Applications include automation, control, energy, HVAC, lighting, and other environmental systems.

"""
__author__ = 'Christian Tremblay'
__version__ = '0.29.29'
__license__ = 'AFL'

import requests
import json
import pandas as pd
import numpy as np
from pandas import Series
import matplotlib.pyplot as plt
import csv
import re,datetime


class HaystackConnection():
    """
    Abstact class / Make a connection object to haystack server using requests module
    A class must be made for different type of server. See NiagaraAXConnection(HaystackConnection)
    """
    def __init__(self, url, username, password):
        """
        Set local variables
        Open a session object that will be used for connection, with keep-alive feature
            baseURL : http://XX.XX.XX.XX/ - Server URL
            queryURL : ex. for nhaystack = baseURL+haystack = http://XX.XX.XX.XX/haystack
            USERNAME : used for login
            PASSWORD : used for login
            COOKIE : for persistent login
            isConnected : flag to be used for connection related task (don't try if not connected...)
            s : requests.Session() object
            _filteredList : List of histories created by getFilteredHistories 
            timezone : timezone from site description
        """
        self.baseURL = url
        self.queryURL = ''
        self.USERNAME = username
        self.PASSWORD = password
        self.COOKIE = ''
        self.isConnected = False
        self.s = requests.Session()
        self._filteredList = []
        self.timezone = 'UTC'
        
    def authenticate(self):
        """
        This function must be overridden by specific server connection to fit particular needs (urls, other conditions)
        """
        pass
    def getJson(self,urlToGet):
        """
        Helper for GET request. Retrieve information as json string objects
        urlToGet must include only the request ex. "read?filter=site"
        Queryurl (ex. http://serverIp/haystack) is already known
        """
        if self.isConnected:
            try:
                req = self.s.get(self.queryURL + urlToGet, headers={'accept': 'application/json; charset=utf-8'})
                #print 'GET : %s | url : %s' % (req.text, urlToGet)
                return json.loads(req.text)
            except requests.exceptions.RequestException as e:
                print 'Request GET error : %s' % e
        #else:
        #print 'Session not connected to server, cannot make request'
        else:
            print 'Session not connected to server, cannot make request'
        
    def getZinc(self,urlToGet):
        """
        Helper for GET request. Retrieve information as default Zinc string objects
        """
        if self.isConnected:
            try:
                req = self.s.get(self.queryURL + urlToGet, headers={'accept': 'text/plain; charset=utf-8'})
                #print 'GET : %s | url : %s' % (req.text, urlToGet)
                return (req.text)
            except requests.exceptions.RequestException as e:
                print 'Request GET error : %s' % e
        else:
            print 'Session not connected to server, cannot make request'
    
    def postRequest(self,url,headers={'token':''}):
        """
        Helper for POST request
        """
        try:
            req = self.s.post(url, params=headers,auth=(self.USERNAME, self.PASSWORD))
            #print 'Post request response : %s' % req.status_code
            #print 'POST : %s | url : %s | headers : %s | auth : %s' % (req, url, headers,self.USERNAME) Gives a 404 response but a connection ????
        except requests.exceptions.RequestException as e:    # This is the correct syntax
            print 'Request POST error : %s' % e
    
    def refreshHisList(self):
        """
        This function retrieves every histories in the server and returns a list of id
        """
        print 'Retrieving list of histories (trends) in server, please wait...'
        self.allHistories = Histories(self)
        print 'Complete... Use hisAll() to check for trends or refreshHisList() to refresh the list' 
        print 'Try hisRead() to load a bunch of trend matching criterias' 
    
    def hisAll(self):
        """
        Returns all history names and id
        """
        return self.allHistories.getListofIdsAndNames()
 
    def hisRead(self,ALL=False,**kwargs):
        """
        This method returns a list of history records
        arguments are : 
        ids : a ID or a list of ID 
        AND_search : a list of keywords to look for in trend names
        OR_search : a list of keywords to look for in trend names
        rng : haystack range (today,yesterday, last24hours...
        start : string representation of start time ex. '2014-01-01T00:00' 
        end : string representation of end time ex. '2014-01-01T00:00'
        """
        self._filteredList = [] # Empty list to be returned
        # Keyword Arguments
        ids = kwargs.pop('id','')
        AND_search = kwargs.pop('AND_search','')
        OR_search = kwargs.pop('OR_search','')
        rng = kwargs.pop('rng','')
        start = kwargs.pop('start','')
        end = kwargs.pop('end','')
        # Remaining kwargs...
        if kwargs: raise TypeError('Unknown argument(s) : %s' % kwargs)
        
        # Build datetimeRange based on start and end
        if start and end:
            datetimeRange = start+','+end
        else:
            datetimeRange = rng
        
        
        # Find histories matching ALL keywords in AND_search
        for eachHistory in self.hisAll():
            takeit = False
            # Find histories matching ANY keywords in OR_search
            if AND_search and all([keywords in eachHistory['name'] for keywords in AND_search]):
                print 'AND_search : Adding %s to recordList' % eachHistory['name']                
                takeit = True
                
            # Find histories matching ANY ID in id list       
            elif OR_search and any([keywords in eachHistory['name'] for keywords in OR_search]):
                print 'OR_search : Adding %s to recordList' % eachHistory['name']                
                takeit = True
                
            elif ids and any([id in eachHistory['id'] for id in ids]):
                print 'ID found : Adding %s to recordList' % eachHistory['name']
                takeit = True
            
            elif ALL:
                print 'Taking all histories : Adding %s to recordList' % eachHistory['name']
                takeit = True
                
            if takeit:
                self._filteredList.append(HisRecord(self,eachHistory['id'],datetimeRange))
            

        if self._filteredList == []:
            print 'No trends found... sorry !'
        
        return self._filteredList

class NiagaraAXConnection(HaystackConnection):
    """
    This class connects to NiagaraAX and fetch haystack servlet
    A session is open and authentication will persist
    """
    def __init__(self,url,username,password):
        """
        Define Niagara AX specific local variables : url
        Calls the authenticate function
        """
        HaystackConnection.__init__(self,url,username,password)
        self.loginURL = self.baseURL + "login/"
        self.queryURL = self.baseURL + "haystack/"
        self.requestAbout = "about"
        self.authenticate()
        
    def authenticate(self):
        """
        Login to the server
        Get the cookie from the server, configure headers, make a POST request with credential informations.
        When connected, ask the haystack for "about" information and print connection information
        """
        print 'pyhaystack %s | Authentication to %s' % (__version__,self.loginURL)
        print 'Initiating connection'
        try :
            # Try to reach server before going further 
            connection_status = self.s.get(self.loginURL).status_code
        except requests.exceptions.RequestException as e:
            connection_status = 0
            
        if connection_status == 200:
            print 'Initiating authentication'
            try:
                self.COOKIE = self.s.get(self.loginURL).cookies
            except requests.exceptions.RequestException as e:
                print 'Problem connecting to server : %s' % e

            if self.COOKIE:
                self.COOKIEPOSTFIX = self.COOKIE['niagara_session']
                self.headers = {'cookiePostfix' : self.COOKIEPOSTFIX
                               }
            self.headers =  {'token':'',
                             'scheme':'cookieDigest',
                             'absPathBase':'/',
                             'content-type':'application/x-niagara-login-support',
                             'Referer':self.baseURL+'login/',
                             'accept':'application/json; charset=utf-8'
                            }
            # Authentication post request
            try:
                req = self.s.post(self.loginURL, params=self.headers,auth=(self.USERNAME, self.PASSWORD))
                #If word 'login' is in the response page, consider login failed...
                if re.search(re.compile('login', re.IGNORECASE), req.text):
                    self.isConnected = False
                    print 'Connection failure, check credentials'
                else:
                    self.isConnected = True
                    print 'User logged in...'                
            except requests.exceptions.RequestException as e:
                print 'Request POST error : %s' % e
        else:
            print 'Connection failed, check your parameters or VPN connection...'
        
        #Continue with haystack login
        if self.isConnected:
            self.about = self.getJson(self.requestAbout)
            self.serverName = self.about['rows'][0]['serverName']
            self.haystackVersion = self.about['rows'][0]['haystackVersion']
            self.axVersion = self.about['rows'][0]['productVersion']
            print 'Connection made with haystack on %s (%s) running haystack version %s' %(self.serverName,self.axVersion,self.haystackVersion)        
            self.timezone = 'America/' + self.getJson('read?filter=site')['rows'][0]['tz']
            print 'Time Zone used : %s' % self.timezone
            self.refreshHisList()    
            

class Histories():
    """
    This class gathers every histories on the Jace
    """
    def __init__(self, session):
        self._allHistories = []
        #self._filteredList = []
        self._his = {'name':'',
                     'id':''}
               
        for each in session.getJson("read?filter=his")['rows']:
            self._his['name'] = each['id'].split(' ',1)[1]
            self._his['id'] = each['id'].split(' ',1)[0]
            #self._his['data'] = ''#No data right now
            self._allHistories.append(self._his.copy())
            
    def getListofIdsAndNames(self):
        return self._allHistories

class UnknownHistoryType(Exception):
    """
    Utility Exception class needed when dealing with non-standard histories
    Analyse_zone for example wich is a custom historical trend
    """
    pass

class HisRecord():
    """
    This class is a single record
    - hisId is the haystack Id of the trend
    - data is created as DataFrame to be used directly in Pandas
    """
    def __init__(self,session,hisId,dateTimeRange='today'):
        """
        GET data from server and fill this object with historical info
        """
        self.hisId = hisId
        self.name = self.getHisNameFromId(session,self.hisId)
        index = []
        values = []

        for eachRows in session.getJson('hisRead?id='+self.hisId+'&range='+dateTimeRange)['rows']:
            index.append(pd.Timestamp(pd.to_datetime(datetime.datetime(*map(int, re.split('[^\d]', eachRows['ts'].split(' ')[0])[:-2])))))
            if isfloat(float(eachRows['val'])):
                values.append(float(eachRows['val']))
            
            elif (eachRows['val'] == 'F'):
                values.append(False)
            elif (eachRows['val'] == 'T'):
                values.append(True)
        
        try:
            #Declare Series and localize using Site Timezone
            self.data = Series(values,index=index).tz_localize(session.timezone)
            #Renaming index so the name will be part of the serie
            self.data = self.data.reindex(self.data.index.rename([self.name]))
        except Exception:
            print '%s is an Unknown history type' % self.hisId 
    
    def getHisNameFromId(self,session,id):
        """
        Retrieve name from id of an history
        """
        for each in session.getJson("read?filter=his")['rows']:
            if each['id'].split(' ',1)[0] == id:
                return (each['id'].split(' ',1)[1])
        return 'Id Not found'    
        
    def plot(self):
        """
        Draw a graph of the DataFrame
        """
        self.data.plot()
        
    def breakdownPlot(self, startTime = '08:00', endTime = '17:00', bins=np.array([0,0.5,1,18.0,18.5,19.0,19.5,20.0,20.5,21.0,21.5,22.0,22.5,23.0, 23.5, 24.0, 24.5,25.0])):
        """
        By default, creates a breakdown plot of temperature distribution between 18 and 25
        bins (distribution) can be past as argument
        By default, takes values between 8:00 and 17:00
        startTime = string representation of time (ex. '08:00')
        endtime = string representation of time (ex. '17:00')
        bin = np.array representing distribution
        """
        x = self.data.between_time(startTime,endTime)
        barplot = pd.cut(x.dropna(),bins)
        x.groupby(barplot).size().plot(kind='bar')
        #self.data.groupby(barplot).size()
    
    def simpleStats(self):
        """
        Shortcut for describe() pandas version
        """
        return self.data.describe()
        
    def __str__(self):
        return 'History Record of %s' % self.getHisNameFromId(self.hisId)
    
    

def isfloat(value):
    """
    Helper function to detect if a value is a float 
    """
    try:
        float(value)
        return True
    except ValueError:
        return False    

def prettyprint(jsonData):
    """
    Pretty print json object
    """
    print json.dumps(jsonData, sort_keys=True, indent=4)