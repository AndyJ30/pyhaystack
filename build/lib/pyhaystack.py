#!python
# -*- coding: utf-8 -*-
"""
File : pyhaystack.py (2.x)
This module allow a connection to a haystack server
Feautures provided allow user to fetch data from the server and eventually, to post to it.

See http://www.project-haystack.org for more details

Project Haystack is an open source initiative to streamline working with data from the Internet of Things. We standardize semantic data models and web services with the goal of making it easier to unlock value from the vast quantity of data being generated by the smart devices that permeate our homes, buildings, factories, and cities. Applications include automation, control, energy, HVAC, lighting, and other environmental systems.

"""
__author__ = 'Christian Tremblay'
__version__ = '0.29.8'
__license__ = 'AFL'

import requests
import json
import pandas as pd
from pandas import Series
import matplotlib.pyplot as plt
import csv
import re,datetime


class HaystackConnection():
    """
    Abstact class / Make a connection object to haystack server using requests module
    A class must be made for different type of server. See NiagaraAXConnection(HaystackConnection)
    """
    def __init__(self, url, username, password):
        """
        Set local variables
        Open a session object that will be used for connection, with keep-alive feature
            baseURL : http://XX.XX.XX.XX/ - Server URL
            queryURL : ex. for nhaystack = baseURL+haystack = http://XX.XX.XX.XX/haystack
            USERNAME : used for login
            PASSWORD : used for login
            COOKIE : for persistent login
            isConnected : flag to be used for connection related task (don't try if not connected...)
            s : requests.Session() object
            filteredList : List of histories created by getFilteredHistories 
        """
        self.baseURL = url
        self.queryURL = ''
        self.USERNAME = username
        self.PASSWORD = password
        self.COOKIE = ''
        self.isConnected = False
        self.s = requests.Session()
        self._filteredList = []
        self.timezone = 'UTC'
    def authenticate(self):
        """
        This function must be overridden by specific server connection to fit particular needs (urls, other conditions)
        """
        pass
    def getJson(self,urlToGet):
        """
        Helper for GET request. Retrieve information as json string objects
        """
        if self.isConnected:
            try:
                req = self.s.get(self.queryURL + urlToGet, headers={'accept': 'application/json; charset=utf-8'})
                #print 'GET : %s | url : %s' % (req.text, urlToGet)
                return json.loads(req.text)
            except requests.exceptions.RequestException as e:
                print 'Request GET error : %s' % e
        #else:
        #print 'Session not connected to server, cannot make request'
        else:
            print 'Session not connected to server, cannot make request'
        
    def getZinc(self,urlToGet):
        """
        Helper for GET request. Retrieve information as json string objects
        """
        if self.isConnected:
            try:
                req = self.s.get(self.queryURL + urlToGet, headers={'accept': 'text/plain; charset=utf-8'})
                #print 'GET : %s | url : %s' % (req.text, urlToGet)
                return (req.text)
            except requests.exceptions.RequestException as e:
                print 'Request GET error : %s' % e
        else:
            print 'Session not connected to server, cannot make request'
    
    def postRequest(self,url,headers={'token':''}):
        """
        Helper for POST request
        """
        try:
            req = self.s.post(url, params=headers,auth=(self.USERNAME, self.PASSWORD))
            #print 'Post request response : %s' % req.status_code
            #print 'POST : %s | url : %s | headers : %s | auth : %s' % (req, url, headers,self.USERNAME) Gives a 404 response but a connection ????
        except requests.exceptions.RequestException as e:    # This is the correct syntax
            print 'Request POST error : %s' % e
    
    def setHistoriesList(self):
        """
        This function retrieves every histories in the server and returns a list of id
        """
        print 'Retrieving list of histories (trends) in server, please wait...'
        self.allHistories = Histories(self)
        print 'Complete... Use getHistoriesList() to check for trends' 
        print 'Try getFilteredHistoriesListWithData(filter, dateTimeRange) to load a bunch of trend matching a criteria' 
    
    def getHistoriesList(self):
        return self.allHistories.getListofIdsAndNames()
    
    def getFilteredHistoriesListWithData(self,regexfilter,dateTimeRange='today'):
        """
        This method returns a list of history record based on a filter on all histories of the server
        """
        self._filteredList = [] # Empty list
        self._his = {'name':'',
                    'id':'',
                    'data':''}
        for eachHistory in self.allHistories.getListofIdsAndNames():
            if re.search(re.compile(regexfilter, re.IGNORECASE), eachHistory['name']):
                print 'Adding %s to recordList' % eachHistory['name']
                self._his['name'] = eachHistory['name']
                self._his['id'] = eachHistory['id']
                self._his['data'] = HisRecord(self,eachHistory['id'],eachHistory['name'],dateTimeRange)
                self._filteredList.append(self._his.copy())
        return self._filteredList



class NiagaraAXConnection(HaystackConnection):
    """
    This class connects to NiagaraAX and fetch haystack servlet
    A session is open and authentication will persist
    """
    def __init__(self,url,username,password):
        """
        Define Niagara AX specific local variables : url
        Calls the authenticate function
        """
        HaystackConnection.__init__(self,url,username,password)
        self.loginURL = self.baseURL + "login/"
        self.queryURL = self.baseURL + "haystack/"
        self.requestAbout = "about"
        self.authenticate()
        
    def authenticate(self):
        """
        Login to the server
        Get the cookie from the server, configure headers, make a POST request with credential informations.
        When connected, ask the haystack for "about" information and print connection information
        """
        print 'pyhaystack %s | Authentication to %s' % (__version__,self.loginURL)
        print 'Initiating connection'
        try :
            # Try to reach server before going further 
            connection_status = self.s.get(self.loginURL).status_code
        except requests.exceptions.RequestException as e:
            connection_status = 0
            
        if connection_status == 200:
            print 'Initiating authentication'
            try:
                self.COOKIE = self.s.get(self.loginURL).cookies
            except requests.exceptions.RequestException as e:
                print 'Problem connecting to server : %s' % e

            if self.COOKIE:
                self.COOKIEPOSTFIX = self.COOKIE['niagara_session']
                self.headers = {'cookiePostfix' : self.COOKIEPOSTFIX
                               }
            self.headers =  {'token':'',
                             'scheme':'cookieDigest',
                             'absPathBase':'/',
                             'content-type':'application/x-niagara-login-support',
                             'Referer':self.baseURL+'login/',
                             'accept':'application/json; charset=utf-8'
                            }
            # Authentication post request
            try:
                req = self.s.post(self.loginURL, params=self.headers,auth=(self.USERNAME, self.PASSWORD))
                #If word 'login' is in the response page, consider login failed...
                if re.search(re.compile('login', re.IGNORECASE), req.text):
                    self.isConnected = False
                    print 'Connection failure, check credentials'
                else:
                    self.isConnected = True
                    print 'User logged in...'                
            except requests.exceptions.RequestException as e:
                print 'Request POST error : %s' % e
        else:
            print 'Connection failed, check your parameters or VPN connection...'
        
        #Continue with haystack login
        if self.isConnected:
            self.about = self.getJson(self.requestAbout)
            self.serverName = self.about['rows'][0]['serverName']
            self.haystackVersion = self.about['rows'][0]['haystackVersion']
            self.axVersion = self.about['rows'][0]['productVersion']
            print 'Connection made with haystack on %s (%s) running haystack version %s' %(self.serverName,self.axVersion,self.haystackVersion)        
            self.timezone = 'America/' + self.getJson('read?filter=site')['rows'][0]['tz']
            print 'Time Zone used : %s' % self.timezone
            self.setHistoriesList()    
            

class Histories():
    """
    This class gathers every histories on the Jace
    """
    def __init__(self, session):
        self._allHistories = []
        self._filteredList = []
        self._his = {'name':'',
               'id':'',
               'data':''}
       
        
        for each in session.getJson("read?filter=his")['rows']:
            self._his['name'] = each['id'].split(' ',1)[1]
            self._his['id'] = each['id'].split(' ',1)[0]
            self._his['data'] = ''#No data right now
            self._allHistories.append(self._his.copy())
            
    def getListofIdsAndNames(self):
        return self._allHistories

    def getDataFrameOf(self, hisId, dateTimeRange='today'):
            return HisRecord(self,hisId,dateTimeRange)
    


class UnknownHistoryType(Exception):
    """
    Utility Exception class needed when dealing with non-standard histories
    Analyse_zone for example wich is a custom historical trend
    """
    pass

class HisRecord():
    """
    This class is a single record
    - hisId is the haystack Id of the trend
    - data is created as DataFrame to be used directly in Pandas
    """
    def __init__(self,session,hisId, hisName,dateTimeRange):
        """
        GET data from server and fill this object with historical info
        """
        self.hisId = hisId
        self.hisName = hisName
        self.jsonHis = session.getJson('hisRead?id='+self.hisId+'&range='+dateTimeRange)
        index = []
        values = []
        self._timezone = session.timezone

        for eachRows in self.jsonHis['rows']:
            index.append(pd.Timestamp(pd.to_datetime(datetime.datetime(*map(int, re.split('[^\d]', eachRows['ts'].split(' ')[0])[:-2])))))
            if isfloat(float(eachRows['val'])):
                values.append(float(eachRows['val']))
        
        try:
            #Declare Series and localize using Site Timezone
            self.data = Series(values,index=index).tz_localize(self._timezone)
            #Renaming index so the name will be part of the serie
            self.data = self.data.reindex(self.data.index.rename([self.hisName]))
        except Exception:
            print '%s is an Unknown history type' % self.hisId 
    
        
        
    def plot(self):
        """
        Draw a graph of the DataFrame
        """
        self.data.plot()

def isfloat(value):
    """
    Helper function to detect if a value is a float 
    """
    try:
        float(value)
        return True
    except ValueError:
        return False    

def prettyprint(jsonData):
    """
    Pretty print json object
    """
    print json.dumps(jsonData, sort_keys=True, indent=4)